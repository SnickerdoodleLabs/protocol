import {
    Poseidon,
    Field,
    MerkleTree,
    Encoding,
} from 'o1js';

import {
    Identity,
    Membership,
    MembershipWitness,
} from '@circuits/membership.js'

describe("Proof of Membership", () => {
    test("Generate Proof of Membership", async () => {
        // pretend like we're fetching info from the blockchain to construct our anonymity group
        type Names = 'Bob' | 'Alice' | 'Charlie' | 'Olivia';
        let Identities: Map<string, Identity> = new Map<Names, Identity>(
            ['Bob', 'Alice', 'Charlie', 'Olivia'].map((name: string, index: number) => {
                return [
                    name as Names,
                    new Identity({
                        identityTrapdoor: Field.random(), // secret value
                        identityNullifier: Field.random(), // another secret value
                    }),
                ];
            })
        );

        // construct a fake signal, just make it an arbitrary string
        let signal: string = "Here is my signal string."

        // then convert the string to an array of Field elements appropriate for Poseidon hashing
        let signalFields = Encoding.stringToFields(signal);

        // NOTE: verifier should compute these quantities for themselves upon receiving the signal string
        let signalHash: Field = Poseidon.hash([...signalFields]);
        let signalHashSquared: Field = signalHash.mul(signalHash);

        // Compress the anonymity group into a Merkle Tree object
        const Identity_Tree = new MerkleTree(16); // MembershipWitness assumes tree w/ 2^16 leaves
        Identity_Tree.setLeaf(0n, Identities.get('Bob')!.leaf());
        Identity_Tree.setLeaf(1n, Identities.get('Alice')!.leaf());
        Identity_Tree.setLeaf(2n, Identities.get('Charlie')!.leaf());
        Identity_Tree.setLeaf(3n, Identities.get('Olivia')!.leaf());

        // calculate the merkleRoot from the tree object
        let merkleRoot: Field = Identity_Tree.getRoot(); // Calculate your merkleRoot reference (this can be computed independently by anyone)

        // construct the private witness object for Bob
        let userIndex = BigInt(0); 
        let userIdentity = Identities.get('Bob')!;
        let w = Identity_Tree.getWitness(userIndex); // calculate the witness for the first slot with your private data
        let witness = new MembershipWitness(w);

        // compute the signal nullifier from user's secret identityNullifier
        // FYI: the order of the array in the Poseidon hash matters
        let epochNullifier: Field = Field.random();
        let signalNullifier: Field = Poseidon.hash([userIdentity.identityNullifier, epochNullifier]);

        // for a given static circuit, proving keys must be generated once-for-all
        console.time('generating keypair...');
        const kp = await Membership.generateKeypair(); // needed to generate circuit proof
        console.timeEnd('generating keypair...');
        let vk = kp.verificationKey(); // needed to verify circuit proof

        // NOTE: this step would happen client-side
        console.log('prove...');
        console.time('prove...');
        // inputs are: [private input array], [public input array], keypair from .generateKeypair()
        const proof = await Membership.prove([userIdentity, witness], [merkleRoot, epochNullifier, signalNullifier, signalHash, signalHashSquared], kp); 
        console.timeEnd('prove...');

        // NOTE: this step would happen server-side
        console.log('verify...');
        console.time('verify...');
        // inputs are: [public input array], verification key, proof generated by calling .prove()
        let ok = await Membership.verify([merkleRoot, epochNullifier, signalNullifier, signalHash, signalHashSquared], vk, proof);
        console.timeEnd('verify...');

        expect(ok).toBe(true);
    });
});