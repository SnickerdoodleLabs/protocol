/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { ObjectUtils } from "@snickerdoodlelabs/common-utils";
import { Poseidon, Field, Encoding } from "o1js";

import { Commitment } from "@circuits/Commitment.js";
import { Identity } from "@circuits/Identity.js";

class CommitmentMocks {
  static generateIdentities(count: number): Identity[] {
    const identities = new Array<Identity>();

    for (let i = 0; i < count; i++) {
      identities.push(
        new Identity({
          identityTrapdoor: Field.random(),
          identityNullifier: Field.random(),
        }),
      );
    }
    return identities;
  }
}

describe("Proof of Commitment", () => {
  test("Generate Proof of Commitment", async () => {
    // pretend like we're fetching info from the blockchain to construct our anonymity group
    const identities = CommitmentMocks.generateIdentities(1);
    const userIdentity = identities[0];
    const commitment = userIdentity.leaf();

    // construct a fake signal, just make it an arbitrary string
    const signal = "Here is my signal string.";

    // then convert the string to an array of Field elements appropriate for Poseidon hashing
    const signalFields = Encoding.stringToFields(signal);

    // NOTE: verifier should compute these quantities for themselves upon receiving the signal string
    const signalHash = Poseidon.hash([...signalFields]);
    const signalHashSquared = signalHash.mul(signalHash);

    // for a given static circuit, proving keys must be generated once-for-all
    console.time("generating keypair...");
    const kp = await Commitment.generateKeypair(); // needed to generate circuit proof
    console.timeEnd("generating keypair...");

    const vk = kp.verificationKey(); // needed to verify circuit proof

    // NOTE: this step would happen client-side
    console.log("prove...");
    console.time("prove...");
    // inputs are: [private input array], [public input array], keypair from .generateKeypair()
    const proof = await Commitment.prove(
      [userIdentity],
      [commitment, signalHash, signalHashSquared],
      kp,
    );
    console.timeEnd("prove...");

    const serializedProof = ObjectUtils.serialize(proof);

    // NOTE: this step would happen server-side
    console.log("verify...");
    console.time("verify...");
    // inputs are: [public input array], verification key, proof generated by calling .prove()
    const ok = await Commitment.verify(
      [commitment, signalHash, signalHashSquared],
      vk,
      ObjectUtils.deserialize(serializedProof),
    );
    console.timeEnd("verify...");

    expect(ok).toBe(true);
  }, 20000);
});
