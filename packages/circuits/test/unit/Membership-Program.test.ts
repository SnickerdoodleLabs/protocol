/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { Poseidon, Field, MerkleTree, Encoding, verify } from "o1js";

import { Identity } from "@circuits/o1jsCircuits/Identity.js";
import {
  MembershipWitness,
  MembershipVerifyParams,
  membershipVerification,
} from "@circuits/o1jsCircuits/Membership.js";

class MembershipMocks {
  static generateIdentities(count: number): Identity[] {
    const identities = new Array<Identity>();

    for (let i = 0; i < count; i++) {
      identities.push(
        new Identity({
          identityTrapdoor: Field.random(),
          identityNullifier: Field.random(),
        }),
      );
    }
    return identities;
  }
}

describe("membershipVerification ZkProgram", () => {
  test("Generate Proof of Membership Via Commitments", async () => {
    // pretend like we're fetching info from the blockchain to construct our anonymity group
    const identities = MembershipMocks.generateIdentities(4);

    // construct a fake signal, just make it an arbitrary string
    const signal = "Here is my signal string.";

    // then convert the string to an array of Field elements appropriate for Poseidon hashing
    const signalFields = Encoding.stringToFields(signal);

    // NOTE: verifier should compute these quantities for themselves upon receiving the signal string
    const signalHash = Poseidon.hash([...signalFields]);
    const signalHashSquared = signalHash.mul(signalHash);

    // Compress the anonymity group into a Merkle Tree object
    const identityTree = new MerkleTree(16); // MembershipWitness assumes tree w/ 2^16 leaves
    identities.forEach((identity, index) => {
      identityTree.setLeaf(BigInt(index), identity.leaf());
    });

    // calculate the merkleRoot from the tree object
    const merkleRoot: Field = identityTree.getRoot(); // Calculate your merkleRoot reference (this can be computed independently by anyone)

    // construct the private witness object for Bob
    const userIndex = 0n;
    const userIdentity = identities[0];
    const w = identityTree.getWitness(userIndex); // calculate the witness for the first slot with your private data
    const witness = new MembershipWitness(w);

    // compute the signal nullifier from user's secret identityNullifier
    // FYI: the order of the array in the Poseidon hash matters
    const epochNullifier = Poseidon.hash(
      Encoding.stringToFields("epochNullifier"),
    );
    const signalNullifier = Poseidon.hash([
      userIdentity.identityNullifier,
      epochNullifier,
    ]);

    // stuff the data into a helper struct
    const membershipParams = new MembershipVerifyParams({
      merkleRoot: merkleRoot,
      epochNullifier: epochNullifier,
      signalNullifier: signalNullifier,
      signalHash: signalHash,
      signalHashSquared: signalHashSquared,
    });

    // for a given static circuit, proving keys must be generated once-for-all
    console.time("generating keypair...");
    const { verificationKey } = await membershipVerification.compile(); // needed to generate circuit proof
    console.timeEnd("generating keypair...");

    // NOTE: this step would happen client-side
    console.log("prove...");
    console.time("prove...");
    // inputs are: [private input array], [public input array], keypair from .generateKeypair()
    const proof = await membershipVerification.proofOfMembership(
      membershipParams,
      userIdentity,
      witness,
    );
    console.timeEnd("prove...");

    const serializedProof = proof.toJSON();

    // NOTE: this step would happen server-side
    console.log("verify...");
    console.time("verify...");
    // inputs are: [public input array], verification key, proof generated by calling .prove()
    await verify(serializedProof, verificationKey);
    console.timeEnd("verify...");
  }, 40000);
});
