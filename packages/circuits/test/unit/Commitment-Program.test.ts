/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { Poseidon, Field, verify } from "o1js";

import {
  CommitmentVerifyParams,
  commitmentVerification,
} from "@circuits/Commitment.js";
import { Identity } from "@circuits/Identity.js";

class CommitmentMocks {
  static generateIdentities(count: number): Identity[] {
    const identities = new Array<Identity>();

    for (let i = 0; i < count; i++) {
      identities.push(
        new Identity({
          identityTrapdoor: Field.random(),
          identityNullifier: Field.random(),
        }),
      );
    }
    return identities;
  }
}

describe("commitmentVerification ZkProgram", () => {
  test("Generate Proof of Commitment", async () => {
    // pretend like we're about to opt into a consent contract and generate an identity object
    const identities = CommitmentMocks.generateIdentities(1);
    const userIdentity = identities[0];

    // for a given static circuit, proving keys must be generated once-for-all
    console.time("compiling...");
    const { verificationKey } = await commitmentVerification.compile(); // needed to generate circuit proof
    console.timeEnd("compiling...");

    // the signal is our leaf of the merkle set
    const signal = userIdentity.leaf();
    const signalHash = Poseidon.hash([signal]);
    const signalHashSquared = signalHash.mul(signalHash);

    const commitmentParams = new CommitmentVerifyParams({
      commitmentLeaf: userIdentity.leaf(),
      signalHash: signalHash,
      signalHashSquared: signalHashSquared,
    });

    // NOTE: this step would happen client-side
    console.log("prove...");
    console.time("prove...");
    // inputs are: [private input array], [public input array], keypair from .generateKeypair()
    const proof = await commitmentVerification.commitmentVerify(
      commitmentParams,
      userIdentity,
    );
    console.timeEnd("prove...");

    // NOTE: this step would happen server-side
    console.log("verify...");
    console.time("verify...");
    // inputs are: [public input array], verification key, proof generated by calling .prove()
    //await commitmentVerification.verify(proof);
    const ok = await commitmentVerification.verify(proof);;
    console.timeEnd("verify...");
  }, 40000);

  test("Generate Proof of Commitment with independent verify()", async () => {
    // pretend like we're about to opt into a consent contract and generate an identity object
    const identities = CommitmentMocks.generateIdentities(1);
    const userIdentity = identities[0];

    // for a given static circuit, proving keys must be generated once-for-all
    console.time("compiling...");
    const { verificationKey } = await commitmentVerification.compile(); // needed to generate circuit proof
    console.timeEnd("compiling...");

    // the signal is our leaf of the merkle set
    const signal = userIdentity.leaf();
    const signalHash = Poseidon.hash([signal]);
    const signalHashSquared = signalHash.mul(signalHash);

    const commitmentParams = new CommitmentVerifyParams({
      commitmentLeaf: userIdentity.leaf(),
      signalHash: signalHash,
      signalHashSquared: signalHashSquared,
    });

    // NOTE: this step would happen client-side
    console.log("prove...");
    console.time("prove...");
    // inputs are: [private input array], [public input array], keypair from .generateKeypair()
    const proof = await commitmentVerification.commitmentVerify(
      commitmentParams,
      userIdentity,
    );
    console.timeEnd("prove...");

    const serializedProof = proof.toJSON();

    // NOTE: this step would happen server-side
    console.log("verify...");
    console.time("verify...");
    // inputs are: [public input array], verification key, proof generated by calling .prove()
    await verify(serializedProof, verificationKey);
    console.timeEnd("verify...");
  }, 40000);
});
